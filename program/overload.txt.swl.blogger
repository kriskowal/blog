<?xml version='1.0' encoding='UTF-8'?>
<ns0:entry xmlns:ns0="http://www.w3.org/2005/Atom"><ns0:id>tag:blogger.com,1999:blog-3618780804544792727.post-6632369541020181525</ns0:id><ns0:author><ns0:name>Kris Kowal</ns0:name><ns0:email>cowbertvonmoo@gmail.com</ns0:email><ns0:uri>http://www.blogger.com/profile/01443956999129365941</ns0:uri></ns0:author><ns0:content type="html">
&lt;p&gt;I disagree with &lt;a href="http://acmqueue.com/modules.php?name=Content&amp;pa=showpage&amp;pid=315"&gt;Professor Bates' general assertion&lt;/a&gt; on the ACM Queue that overload is bad based on the specific weaknesses of C++.  Bates cites the nightmarish growth of complexity of a C++ program because of a combination of arbitrary complexities.  C++ uses a complex scheme of scope resolution and type casting, with multiple ways to invoke type conversions.  Because C++ provides so many avenues for these features, there are arbitrary distinctions to determine where one begins and another ends.  In a simpler language, as most functional and some procedural languages are, overloading is not a problem because there is only one scope resolution rule and a unified system for defining type conversions.  In fact, that these complexities scale exponentially is considered an advantage; being able to understand how your code scales when it interacts with new code is empowering.&lt;/p&gt;
&lt;p&gt;Bates argues that "[overloading] adds no significant programming capabilities at all."  This overlooks the concept of genericity.  Genericity is a concept implemented in static languages like C++ through the use of templates and in dynamic languages like Python inherently.  Genericity posits that there are classes that are unrelated in terms of inheritance that subscribe to the same notional behaviors as defined by some set of algebraic identities.  So, for all objects that subscribe to the same notion of "addition", a "sum" operator would behave the same way.  Or, for all objects that subscribe the notions of symbolic logic, negating any of those objects once gives you an opposite, and negating again renders an equivalent object to the initial.  This is a significant programming capability.  This permits the implementation of libraries that behave on any object that subscribes to these generic notions.&lt;/p&gt;
&lt;p&gt;I do agree that overloading can get out of hand, especially in the hands of programmers that are simply trying to be brief and have no respect for preserving algebraic identities so that their classes can behave predictably.  Perhaps future languages simply need a way of explicating these generic relationships.  I would be tempted to argue that one can emulate the exact same behaviors with object oriented programing and explicating these relationships with with interfaces, but I doubt this is practical in the long run.  Frankly, some people are willing to give up the effort of explicating their intentions on the expectation that other users have taken the same math classes.&lt;/p&gt;
</ns0:content><ns0:updated>2008-09-30T13:56:41.968-07:00</ns0:updated><ns0:published>2005-08-05T14:42:00.000-07:00</ns0:published><ns0:title type="text">Overloads and Genericity</ns0:title><ns0:link href="http://askawizard.blogspot.com/feeds/6632369541020181525/comments/default" rel="replies" title="Post Comments" type="application/atom+xml" /><ns0:link href="http://www.blogger.com/comment.g?blogID=3618780804544792727&amp;postID=6632369541020181525" rel="replies" title="0 Comments" type="text/html" /><ns0:link href="http://www.blogger.com/feeds/3618780804544792727/posts/default/6632369541020181525" rel="edit" type="application/atom+xml" /><ns0:link href="http://www.blogger.com/feeds/3618780804544792727/posts/default/6632369541020181525" rel="self" type="application/atom+xml" /><ns0:link href="http://askawizard.blogspot.com/2005/08/overloads-and-genericity.html" rel="alternate" title="Overloads and Genericity" type="text/html" /></ns0:entry>
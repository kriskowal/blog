<?xml version='1.0' encoding='UTF-8'?>
<ns0:entry xmlns:ns0="http://www.w3.org/2005/Atom"><ns0:id>tag:blogger.com,1999:blog-3618780804544792727.post-6791280466517758215</ns0:id><ns0:author><ns0:name>Kris Kowal</ns0:name><ns0:email>cowbertvonmoo@gmail.com</ns0:email><ns0:uri>http://www.blogger.com/profile/01443956999129365941</ns0:uri></ns0:author><ns0:content type="html">
&lt;p&gt;Not to name names, but I've been working on integrating code from &lt;a href="http://simile.mit.edu/"&gt;Simile&lt;/a&gt; from MIT into &lt;a href="https://cixar.com/tracs/javascript"&gt;Chiron&lt;/a&gt;.  Refactoring an existing JavaScript project highlights all the things you get for free in Chiron.&lt;/p&gt;
&lt;p&gt;Simile has it's own XHR engine, DOM event wrappers, DOM layout and style functions, PNG transparency solution, and a &lt;tt&gt;SortedArray&lt;/tt&gt; type that provides binary search functions.  Here are some of my observations.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Simile's layout &lt;tt&gt;getSize&lt;/tt&gt; was better than mine.  I will rectify this.&lt;/li&gt;
	&lt;li&gt;Not having a module system makes us reinvent the wheel: frequently.&lt;/li&gt;
	&lt;li&gt;It's hard to write a good XHR engine.  There are a lot of XHR modules out there, most of them have some issue or another: missing browser, doesn't report OK status on local files, doesn't unify browser caching inconsistencies, doesn't support timeouts, doesn't expose XML (the X in AJAX) in IE, or so on.  If you're going to make a new one, you should use these as references and do some serious research, development, and testing.  Otherwise, you should copy or use the best of them (&lt;a href="http://jquery.com/"&gt;jQuery&lt;/a&gt;, in my opinion).  Also, it needs to support asynchronous (the A in AJAX) requests, and you need to use them as often as possible.&lt;/li&gt;
	&lt;li&gt;Not having a solid, modular library makes us lazy.  The inconvenience of name-spacing makes us lazy.  This causes us to write sloppy code.  For example, we should always use an &lt;tt&gt;enquote&lt;/tt&gt; function when we're string interpolating HTML attributes and an &lt;tt&gt;inoculate&lt;/tt&gt; function when we're interpolating HTML, or we should use DOM functions or a DOM wrapper API to generate our HTML.&lt;/li&gt;
	&lt;li&gt;As I integrate code from other libraries, a pattern emerges.  In my first pass, I collapse the name-spaces.  Every module is a name-space, so all the manual creating of hierarchies like &lt;tt&gt;Simile.DOM&lt;/tt&gt; (&lt;tt&gt;Simile = {}&lt;/tt&gt; presumed, then &lt;tt&gt;Simile.DOM = {}&lt;/tt&gt;, then endless repetition of &lt;tt&gt;Simile.DOM&lt;/tt&gt; to augment or use its contents) is unnecessary and undesirable.&lt;/li&gt;
	&lt;p&gt;Referencing URL's of resources, like other scripts and images, relative to the URL of the script you're currently in, is hard.  Starting from scratch, this usually means you're going to have a global URL constant.  This means domain-coupling.  Maybe you make the URL relative to the root.  This means domain-coupling.  Maybe you provide it as a configuration variable.  This means site-coupling.  Maybe you scrape the script tags on the page for the URL of your script then resolve the URL relative to your own URL.  This means you're going to write a lot of slow code for what you perceive to be little value.  In Chiron, you can get a function called &lt;tt&gt;resolve&lt;/tt&gt; from &lt;tt&gt;http.js&lt;/tt&gt; that resolves a URL relative to a base URL.  Chiron also provides your modules with a &lt;tt&gt;moduleUrl&lt;/tt&gt; variable that is the URL of the script you're in.  &lt;tt&gt;resolve&lt;/tt&gt; also implicitly uses this variable as your base URL if you don't provide a second argument(&lt;tt&gt;include('http.js'); resolve('images/blah.gif')&lt;/tt&gt;).&lt;/p&gt;
	&lt;p&gt;Chiron grabs the script tag href of &lt;tt&gt;modules.js&lt;/tt&gt; and removes the &lt;tt&gt;script&lt;/tt&gt; object from the DOM (so other scripts can't sniff it) exactly once, since it needs that URL to resolve other module URL's.  From there, Chiron keeps track of where all of your modules are relative to it and provides that information to each module.&lt;/p&gt;
	&lt;li&gt;About &lt;tt&gt;SortedArray&lt;/tt&gt;:&lt;/li&gt;

	&lt;ul&gt;
		&lt;li&gt;A collection type should create an empty instance if you pass no arguments in.&lt;/li&gt;
		&lt;li&gt;A collection type should populate itself from the values of another collection if you pass one in as its first argument.  This should always be the first argument, even if you frequently create empty collections with overrides on later arguments.  Force your user to pass in a &lt;tt&gt;null&lt;/tt&gt; or &lt;tt&gt;undefined&lt;/tt&gt;.&lt;/li&gt;
		&lt;li&gt;Try to accept &lt;tt&gt;null&lt;/tt&gt; and &lt;tt&gt;undefined&lt;/tt&gt; as equivalent unless the distinction is meaningful.&lt;/li&gt;
		&lt;li&gt;Try to distinguish &lt;tt&gt;null&lt;/tt&gt; and &lt;tt&gt;undefined&lt;/tt&gt; from &lt;tt&gt;0&lt;/tt&gt; in all meaningful cases.&lt;/li&gt;
		&lt;li&gt;Invariants like "sorted" are a promise.  Guarantee your invariants across all function calls, including construction.  If this means an unacceptable performance degradation, permit the user to suppress whatever code you need to verify the invariant if they are willing to provide treated data.&lt;/li&gt;
		&lt;li&gt;If there is a reasonable default, it should always be implicit.  I should not have to explicitly send the global &lt;tt&gt;compare&lt;/tt&gt; function into a &lt;tt&gt;SortedArray&lt;/tt&gt; if I want a &lt;tt&gt;SortedArray&lt;/tt&gt; of types supported by &lt;tt&gt;compare&lt;/tt&gt;.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;li&gt;Not having a system of base types makes for noisy API's where names from different organizations have different meanings.  For example, &lt;tt&gt;find&lt;/tt&gt; functions should always accept the same kinds of arguments and return the same kinds of values.  Simile's name choices are very close to mine, to the effect that they could almost be used as partially implemented duck types for mine, but some of the names would have to be realigned.  &lt;tt&gt;find&lt;/tt&gt; in Simile accepts a comparator and returns an acceptable index to insert or remove a particular element.  &lt;tt&gt;find&lt;/tt&gt; in Chiron returns an index or key at which an item can be inserted or removed, and guarantees that it will be the first occurrence of a given value (not a comparator).  It was very easy to refactor &lt;tt&gt;SortedArray&lt;/tt&gt; to subscribe to the strict model.  Also, &lt;tt&gt;removeAll&lt;/tt&gt; needed to be &lt;tt&gt;clear&lt;/tt&gt;, &lt;tt&gt;length&lt;/tt&gt; and &lt;tt&gt;getCount&lt;/tt&gt; both needed to be &lt;tt&gt;getLength&lt;/tt&gt;, &lt;tt&gt;getIterator&lt;/tt&gt; needed to be &lt;tt&gt;iter&lt;/tt&gt;, &lt;tt&gt;next&lt;/tt&gt; needed to throw &lt;tt&gt;StopIteration&lt;/tt&gt; once in a while, among others.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I'm looking forward to having a semblance of Simile Timeplot and Timechart in the Chiron family.&lt;/p&gt;
</ns0:content><ns0:updated>2008-09-30T13:55:49.359-07:00</ns0:updated><ns0:published>2008-02-19T00:39:00.001-08:00</ns0:published><ns0:title type="text">Integrating Simile</ns0:title><ns0:link href="http://askawizard.blogspot.com/feeds/6791280466517758215/comments/default" rel="replies" title="Post Comments" type="application/atom+xml" /><ns0:link href="http://www.blogger.com/comment.g?blogID=3618780804544792727&amp;postID=6791280466517758215" rel="replies" title="0 Comments" type="text/html" /><ns0:link href="http://www.blogger.com/feeds/3618780804544792727/posts/default/6791280466517758215" rel="edit" type="application/atom+xml" /><ns0:link href="http://www.blogger.com/feeds/3618780804544792727/posts/default/6791280466517758215" rel="self" type="application/atom+xml" /><ns0:link href="http://askawizard.blogspot.com/2008/02/integrating-simile_19.html" rel="alternate" title="Integrating Simile" type="text/html" /></ns0:entry>
1> Python and Javascript

Someone asked me to compare Javascript and Python.  Here's my dense, six page response for the brave...of doom.

So, about Javascript and Python.  The short of it is that Python's inner workings are much more complicated and its interface is much less complicated to use.  Of course, we put up with Javascript because it reaches places Python can not.

The first difference between Python and Javascript is the type system.  I'd say that it's a difference between Object Oriented and Prototype Oriented, but that would be superficial.  The difference is in how programmers choose to craft and reuse their objects and types, not the range of possibilities.  This has broad implications for learn-ability, readability, maintainability, and sanity.

In Python, like Javascript, an object is an associative array.  In Python, in particular, an object is a hash table.  The distinction is that in Python, member selection and item or attribute indexing are distinct services.  You can override selection and indexing separately.  In Javascript, the distinction between indexing and selection exists for numerically indexed <tt>Arrays</tt>, but not lexically indexed <tt>Objects</tt>.  Python's <tt>dict</tt> type has an associative array for its members and another associative array for its items.  This, I find, is wise; the key domains of both attributes and items are open, permitting you to use any key as both a member and an index without a name collision.

[In my library, I've implemented a <tt>Dict</tt> type in <tt>javascript.js</tt> that has such a distinction, but there is still a plain old <tt>Object</tt> inside for sub-containing the items.  Of course, this is only a partial solution.  For one, the hash algorithm is <tt>toString()</tt> rather than something numeric and real.  Hash keys still collide with <tt>Object</tt> members like <tt>valueOf</tt>, which we simply can't iterate using <tt>Dict keys</tt>.  Also in Javascript, you can only use <tt>Strings</tt> as item keys.  Silly.  Nominally, I'll implement a real hash table using an <tt>Array</tt> internally and some suitable default hash function.]

In Javascript, member selection is always <i>O(1)</i> (or <i>O(n)</i> where <i>n</i> is the number of members in the <tt>Object</tt> I suspect since their order of insertion appears to be preserved).  That's nice.  In Python, member selection is directly proportional to count of base classes.  Python has sane multiple inheritance; it calculates a method resolution order (MRO) when types are created that determines the order that member lookup visits your base classes when searching for an attribute.

On the flip side, in Python, object creation is <i>O(1)</i>; related only to the time needed to create an internal hash table referring to its its <tt>__class__</tt> and running its <tt>__init__</tt>ializer.  In Javascript, the performance of Object creation is related to the count of members in your base classes, the time needed to copy your prototype.

Aside from construction and look-up costs, Python member data are observable.  In Python, you can safely expose your member data in your context object, for example <tt>self.attr = 10</tt>.  If you later need it observe an attribute's access or mutation, you can easily override member access and mutation for the entire class or a particular variable.  In languages that do not provide this feature, you either run the risk of breaking backwards compatibility with old libraries as Borland famously did with their window menu attribute, or use the best practice of C++, Java, and Objective-C: always provide accessors and mutators for any public member data.  Javascript native types do not encourage this pattern, so it's no surprise that most Javascript libraries we see today provide fragile interfaces.

[In my library, I don't use prototype oriented programming.  For one, prototypes don't support multiple-inheritance or interface inheritance in a Python or Java sense.  Instead, you typically augment the prototype by copying members from another object which causes a certain loss of data, leaving you unable to detect inheritance relationships at run time, much less use them to reliably override member functions of your immediate parent type.  I miss "mix-ins" when using native Javascript coming from Python.

[For two, I find closures handy for holding private data, using the context object only for public interfaces.  This is necessary design in my opinion because, like in C++ or Java 4, you can't change your mind about whether you want to observe an attribute later on.  You must provide interfaces for accessing and mutating your members up front (for example, <tt>var atty, this.getAtty, this.setAtty</tt>).  Also, this means that each base class can privatize its member data in its own closure.  Python provides class-private-data through behind-the-scenes name-mangling, which I'm not fond of.  In a class, <tt>Foo</tt>, names beginning with double-underscore, <tt>__bar</tt>, are mangled in the internal associative array, <tt>_Foo__bar</tt> to avoid name collisions.

[In Python, member manipulations call <tt>hasattr</tt>, <tt>getattr</tt>, <tt>setattr</tt>, and <tt>delattr</tt> in the background.  Since this is only even <i>possible</i> to emulate in Gecko (and inelegant when possible), I don't want to force a user to call <tt>getAttr</tt>, <tt>setAttr</tt>, <tt>delAttr</tt>, and <tt>hasAttr</tt> to explicate member manipulation, and I want to use closures to privatize each layer of inheritance, I forego properties and virtual attributes and  simulate the remaining features of Python by implementing Python's "C3 monotonic method resolution order" that cleverly sidesteps the big issues with multiple-inheritance from previous generation languages.  Of course, my implementation still has bugs and I don't yet fully understand how to fix them.  Meh, soon.

[When I create a new type, I calculate it's MRO, then I call each of its initialization closures starting at the bottom of the inheritance hierarchy (<tt>js.Object</tt>), decorating the context object as it traverses upward.  Thus, sub-classes override the members of base-classes.  However, I don't want to lose the ability to call methods of the super-class completely, so I create an <tt>Interface</tt> object for each base class after each initializer.  These interfaces can be accessed by calling <tt>getSuper()</tt> and <tt>as(<i>type</i>)</tt> from any other interface, a feature less elegantly provided in Python using <tt>super(<i>Self</i>, <i>self</i>)</tt>.  The top-most interface is your instance object after construction.

[This is pretty heavy-duty, so I only use these types for public interfaces, favoring Javascript primitives internally.  I provide easy conversions between <tt>Dict</tt> and <tt>Object</tt> as well as <tt>List</tt> and <tt>Array</tt>.  This is insane; I blame Javascript.  The good news is that object oriented programming will just work.]

So, here's the big fracture: How do you get more out of your base types?  Javascript, Ruby, Smalltalk and Objective-C take the high road and let you augment your base classes.  In Python, all of your base types are highly optimized immutable C data structures.  Meanwhile, in Javascript, unlike some of those other languages, it's undesirable to augment your base classes for other numerous reasons.  For one, adding members to <tt>Object</tt> is equivalent to adding items to all your <tt>Objects</tt>.  I'm convinced this is a Javascript design flaw more than anything else.  You've pointed this out before yourself.  There's also the design risk.  Suddenly, modules can trample each-other's much-needed changes to each other's objects.  Silly.  Also, augmenting bases steepens the learning curve.  Suddenly, base classes like, say, <tt>Number</tt>, contain functions that have nothing to do with numbers, say, <tt>toColorPart</tt>.  Furthermore, augmenting base classes in Javascript means that they take longer to initialize.  This impacts performance of the entire system when you only want to add functionality to a surgical segment.  Gah!

Python lets you augment anything but your base classes, so you generally don't use this technique.   Instead, Python has a convention of using module functions instead of member functions to add functionality to a program.  The general pattern is that you create <tt>my_module.my_function</tt>, say <tt>color.color</tt>.  This function checks whether the given value implements <tt>__color__</tt>.  The underscores are silly, but they allegedly help avoid name collisions (They don't.  It would be better to use symbols (in a LISP sense) emitted by the <tt>color.color</tt>, but that's just not as convenient in Python).  So, if value has <tt>__color__</tt>, we call it and return the result.  Otherwise, we check whether the given object is one of our familiar and appropriate base classes, say, <tt>int</tt>, and perform some appropriate default.  [In my library, I favor this technique, save that I use camelCase for both module names and instance names, while TitleCase for type names, and I throw fate to the wind and ditch the underscores.  Words have meanings; I'll write a dictionary instead.]

Python doesn't have a <tt>new</tt> keywords.  Objects are functions; functions are objects.  This means that functions can easily supplant types, so the distinctions get a bit muddy and it's a "good thing".  I've used this trait more than once to hoodwink a module I wrote that anticipates a class name but gets a factory method...or a property (an accessor-mutator pair observing an attribute) that returns a factory method <i>*gasp*</i>...instead.  (In my library, I axe the <tt>new</tt> keyword.  Calling a type returns an instance, period.  Thus, functions and types are interchangeable factories.)

Those are the big differences.

Python has a pretty-good module system with a syntax similar to ML; modules are singleton objects, you can import names from them surgically or in bulk, you can rename items you import, you can rename the module itself when you import it into your names-pace.  You can import a module name relative to the directory your module is in or fall back down the module include path up to the system module root.  Javascript does not have such a system; I wrote one but obviously nobody's using it yet and it has some work to go.

Python and Javascript both support full closures.  Javascript's are more consistent syntactically.  Python also has continuations, generators (lazy lists coming from Haskell), list comprehensions and generator expressions: all handy.  In Python, all objects are callable if they define <tt>__call__</tt>, not just objects inheriting from its analog for <tt>Function</tt>.  Python has weak references which would be handy when dealing with cyclic references between the DOM and Javascript.  Python calls <tt>__del__</tt> on an object before deallocating it; finalizers would also be handy for untying memory between JS and DOM.

On the topic of ways that Python and Javascript work well with each other: JSON.  Python provides a <tt>repr</tt> function (overridable in user defined classes with a <tt>__repr__</tt> attribute).  <tt>repr</tt> attempts to provide the axiom <tt>eval(repr(<i>object</i>)) == <i>object</i></tt> in so far as it makes sense (Python provides much more powerful systems for object serialization, or "pickling", however <tt>repr</tt> is handy for inspecting a program's object graph at run time.)  Conveniently, <tt>repr</tt>s of <tt>dict</tt>s and <tt>list</tt>s are parsable as Javascript <tt>Objects</tt> and <tt>Arrays</tt>.  It doesn't necessarily work the other way around since Python requires that <tt>dict</tt> keys be bound in quotes since you have the option of using variables or expressions as keys.  This is fine though since the direction of trust between a Python server and Javascript is only one way.  Python does not provide secure sand-boxing like Ruby.

I hope this is insightful.

